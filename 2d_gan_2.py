# -*- coding: utf-8 -*-
"""Практика 2D GAN

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O4nJ-Kx6G0VLfXYSP6kkwMOqb_Uz7yyJ

# Практика

В этом практическом задании вы реализуете GAN, которые научится генерировать данные из такого распределения:
![image.png](data:image/png;base64,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)
"""

import tensorflow as tf
#tf.enable_eager_execution()
import matplotlib.pyplot as plt
import numpy as np
from tqdm import tqdm_notebook as tqdm

"""Основные функции из прошлого урока приводятся без изменений (просто выполните клетку ниже)"""

#@title (вспомогательный код -- выполните клетку)

cross_entropy = tf.keras.losses.BinaryCrossentropy(from_logits=True)

def generator_loss(discr_pred_fake_data):
    """
    discr_pred_fake_data -- предсказания дискриминатора на фейковых данных
    """
    labels = tf.ones_like(discr_pred_fake_data)
    # для генератора "хорошо", 
    # когда фейковые данные дискриминатор назвал реальными
    return cross_entropy(labels, discr_pred_fake_data) 

def discriminator_loss(disc_pred_real_data, disc_pred_fake_data):
    """
    disc_pred_real_data -- логиты, предсказанные дискриминатором для реальных данных
    disc_pred_fake_data -- логиты, предсказанные дискриминатором для фейковых данных
    """
    real_labels = tf.ones_like(disc_pred_real_data) # правильные ответ для реальных данных -- 1
    fake_labels = tf.zeros_like(disc_pred_fake_data) # правильные ответ для фейковых данных -- 0
    
    real_loss = cross_entropy(real_labels, disc_pred_real_data)
    fake_loss = cross_entropy(fake_labels, disc_pred_fake_data)

    total_loss = real_loss + fake_loss
    return total_loss

def generate_latent_points(latent_dim, n):
	x_input = np.random.randn(n,  latent_dim)
	return x_input

def generate_fake_samples(generator, n):
    x_input = generate_latent_points(generator.input_shape[1], n)
    X = generator.predict(x_input)
    return X

def show_result(generator, title=""):
    X_fake = generate_fake_samples(generator=generator, n=100)
    X_real = generate_real_samples(n=100)  
    plt.figure()
    plt.title(title)
    plt.scatter(X_real[:, 0], X_real[:, 1], label="real samples")
    plt.scatter(X_fake[:, 0], X_fake[:, 1], label="generated samples")
    plt.legend(loc="best")
    plt.show()

def train_step(discriminator, generator, optimizer, batch_size=128):
    half_batch = int(batch_size / 2)	
    with tf.GradientTape() as gen_tape, tf.GradientTape() as disc_tape:
        # 1. Сэмплируем batch_size/2 точек из реального распределения
        X_real = generate_real_samples(n=half_batch)
        
        # генератор генерирует данные из латентных векторов, которые принадлежат простому распределению
        # и учится превращать их в распределени которое сможет обмануть дискриминатор
        # сначала генерируем латентные вектора -- 
        latent_z = np.random.randn(half_batch,  generator.input_shape[1])
        # а затем превращаем их с помощью генератора в X_fake
        X_fake = generator(latent_z)
        
        # 3. Делаем forward_pass дискриминатора на x_real и x_fake, 
        # получив discr_pred_real_data и discr_pred_fake_data
        discr_pred_real_data = discriminator(X_real)
        discr_pred_fake_data = discriminator(X_fake)

        # 4. Посчитать лосс дискриминатора и генератора
        disc_loss = discriminator_loss(discr_pred_real_data, discr_pred_fake_data)
        gen_loss = generator_loss(discr_pred_fake_data)
    
    # считаем производные
    gradients_of_discriminator = disc_tape.gradient(disc_loss, discriminator.trainable_variables)
    gradients_of_generator = gen_tape.gradient(gen_loss, generator.trainable_variables)
    
    # 5. Обновляем параметры генератора и дискриминатора. 
    optimizer.apply_gradients(zip(gradients_of_discriminator, discriminator.trainable_variables))
    optimizer.apply_gradients(zip(gradients_of_generator, generator.trainable_variables))
    
    return disc_loss.numpy(), gen_loss.numpy()

def train_gan(discriminator, generator, optimizer, n_epochs=10000, n_batch=128,
              show_every=1000):
    losses_hist_disc = []
    losses_hist_gen = []
    for i in tqdm(range(n_epochs)):
        if i % show_every == 0:
            show_result(generator=generator, title=f"Epoch {i}")
            
        disc_loss, gen_loss = train_step(discriminator, generator, optimizer, n_batch)
        losses_hist_disc.append(disc_loss)
        losses_hist_gen.append(gen_loss)
    return losses_hist_disc, losses_hist_gen

def spirals(n_points, noise=0):
    """
    adapted from https://glowingpython.blogspot.com/2017/04/solving-two-spirals-problem-with-keras.html
    """
    n = np.sqrt(np.random.rand(n_points,1)) * 360*1.5 * (2*np.pi)/360
    d1x = -np.cos(n)*n + np.random.rand(n_points,1) * noise
    d1y = np.sin(n)*n + np.random.rand(n_points,1) * noise
    return np.hstack((d1x, d1y)) / 10.

def generate_real_samples(n=100):
    return spirals(n_points=n, noise=0)

original = generate_real_samples(100)
plt.scatter(original[:,0], original[:,1])
plt.show()

"""**Задание**

Подберите архитектуру генератора и дискриминатора таким образом, чтобы научиться генерировать данные из указанного распределения.
"""

def build_generator(latent_dim, n_outputs=2):
    # <YOUR CODE STARTS HERE >
    # Реализуйте генератор. 
    # Т.к. данные находятся в промежутке от -1 до 1, то можно добавить такие ограничения в сеть 
    # с помощью функции активации -- tanh (как сигмоида, только превращает выходы в промежуток от -1 до 1)
    # Мне это помогло ускорить сходимость. Использовать ее необязательно. 
    # Последний слой можно оставить без изменений
    model = tf.keras.models.Sequential()
    model.add(tf.keras.layers.Dense(15, activation='tanh', input_dim=latent_dim))
    model.add(tf.keras.layers.Dense(10, activation='tanh'))
    # <YOUR ENDS STARTS HERE >
    model.add(tf.keras.layers.Dense(n_outputs, activation="tanh"))
    return model

def build_discriminator(n_inputs=2):

    # <YOUR CODE STARTS HERE >
    # Реализуйте дискриминатор. Лосс работает с логитами -- поэтому не забудьте убрать активацию с последнего слоя.
    model = tf.keras.models.Sequential()
    model.add(tf.keras.layers.Dense(10, activation='relu', input_dim=n_inputs))
    model.add(tf.keras.layers.Dense(10, activation='relu'))
    model.add(tf.keras.layers.Dense(1))
    # <YOUR CODE ENDS HERE >
    return model

# вы можете изменить этот параметр
latent_dim = 10

generator = build_generator(latent_dim=latent_dim, n_outputs=2)
discriminator = build_discriminator(n_inputs=2)

optimizer = tf.keras.optimizers.Adam(learning_rate=0.001, beta_1=0.5) # параметры оптимизатора можно тоже менять, но 
                                                                      # но и с этими может получиться :)

losses_hist_disc, losses_hist_gen = train_gan(discriminator, generator, optimizer, n_epochs=10000,
          show_every=1000)

show_result(generator=generator)
show_result(generator=generator)